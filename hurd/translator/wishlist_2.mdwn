## <a name="Introduction"> Introduction </a>

The idea behind file system translators is a powerful concept which hasn't recieved much attention in the mainstream computing world. So here is a list of interesting translators I've been able to dream up. I'm sure there are many more ideas floating around out there, so add them to the list!

The [ferris project](http://witme.sourceforge.net/libferris.web/features.html) has some great ideas and code in the area of userspace dynamic filesystems, as has the [FUSE project](http://fuse.sourceforge.net/).

## <a name="Audio_cdfs"> Audio\_cdfs </a>

A translator which produces a directory of \*.wav files when you have an audio CD in the drive.

## <a name="Ogg"> Ogg </a>

This translator could be a sub-directory of the Audio\_cdfs translator and it would translate the \*.wav files into Ogg Vorbis/MP3 format.

## <a name="CDDB"> </a> CDDB

Of course it would be a lot nicer if the above two translators didn't name their files something worthless like track001.ogg. So we would want a translator which would hook up with a database on the web and produce meaningful file names.

## <a name="Crypto"> Crypto </a>

A cryptographic/steganographic seem like a nice match with the concept of user-land file systems. I like the idea of something like `settrans -a /secure stegfs --mpeg file001.mpg`

## <a name="Revision_control"> Revision control </a>

All of the empty space on your drive is now being wasted. Why not have a revision control translator which tracks changes to your documents? See also [this guy](http://www.linuxjournal.com/article.php?sid=5976). And then you'd do something like `cd /time-machine/2003/sept/14/` to see what your system looked like on the 14th of septempber 2003.

## <a name="CVSFS"> </a> CVSFS

See [cvsFS for Linux](http://cvsfs.sourceforge.net/). This provides a package which presents the CVS contents as mountable file system. It allows to view the versioned files as like they were ordinary files on a disk. There is also a possibility to check in/out some files for editing. A read-only version has been written by Stefan Siegl and is available at [Berlios](http://cvs.berlios.de/cgi-bin/viewcvs.cgi/cvsfs4hurd/cvsfs/).

## <a name="tar_and_gzip"> tar and gzip </a>

Rumor has it that they are on the way. Actually, a tar + gzip/bzip2 translator does exist (although it hasn't been used much...) : see [the Hurdextras project](http://savannah.nongnu.org/projects/hurdextras/) on Savannah.

## <a name="ROM"> </a> ROM

How about a translator which makes it look like you can write to read only media (like CDs), or change files which I don't have permission to change. This translator would make it seem like you could copy files to places where you normally couldn't. Think about combining this translator with the ftp translator and the tar and gzip translators. (cd /ftp/gnu.org/gnome.tar.gz/writes\_allowed; make install). It could be that unionfs does this very thing.

## <a name="Super_FIFO"> Super\_FIFO </a>

It's like a named pipe which is smart enough to start a process everytime something new tries to read from it. For example, let's say I have a script that reads in a JPEG image and spits out a smaller thumbnail \*.jpg to STDOUT. With a standard fifo (`mknod -p fifo`) this would almost works (`script big.jpg > fifo`). But what if there are two processes trying to read the fifo at once? Ick. And of course the standard way only works once without rerunning the command. I'm not quite sure what the syntax should look like, but I'm sure someone out there has a great idea waiting to happen.

## <a name="Perl"> Perl </a>

Perl is a wonderful language for hacking together something useful in a short amount of time. No concept is complete without being able to use it in a perl one-liner. And that goes for Hurd translators too. Right?

    #!/usr/bin/perl
    use Hurd::translator;

    #file named "two" can produce an endless supply of twos, etc. (a la /dev/zero)
    my $i=0;
    for $filename ([zero one two three four])
    {
       $libtrivfsread_codehash{$filename}=
                sub{ $num_bytes=shift; my $data=$i; return chr($data) x $num_bytes; };
       #that's a hash of references to closures
       $i++;
    }
    translator_startup();

A Perl translator has been started by [John Edwin Tobey](http://john-edwin-tobey.org/Hurd/) (pith).

## <a name="Source_code"> Source code </a>

Here's a crazy thought. How about a translator for source code. You have a C source file like `hello.c` which is your normal everyday file. But there's a translator sitting underneath, so when you `cd hello.c` you get a directory with files like `main()` which represent the subroutines in `hello.c`. And of course you should be able to edit/remove those and have it modify the original source.

## <a name="Libraries"> Libraries </a>

Here's an [idea](http://www.circlemud.org/~jelson/software/fusd/docs/node13.html) from the people making [userspace drivers in Linux](http://www.circlemud.org/~jelson/software/fusd/):

* "One particularly interesting application of FUSD that we've found very useful is as a way to let regular user-space libraries export device file APIs. For example, imagine you had a library which factored large composite numbers. Typically, it might have a C interface--say, a function called `int *factorize(int bignum)`. With FUSD, it's possible to create a device file interface--say, a device called `/dev/factorize` to which clients can `write(2)` a big number, then `read(2)` back its factors.

* This may sound strange, but device file APIs have at least three advantages
  over a typical library API. First, it becomes much more language
  independent--any language that can make [[system call]]s can access the
  factorization library. Second, the factorization code is running in a
  different address space; if it crashes, it won't crash or corrupt the
  caller. Third, and most interestingly, it is possible to use `select(2)` to
  wait for the factorization to complete. `select(2)` would make it easy for a
  client to factor a large number while remaining responsive to other events
  that might happen in the meantime. In other words, FUSD allows normal
  user-space libraries to integrate seamlessly with UNIX's existing,
  POSIX-standard event notification interface: `select(2)`."

## <a name="Mail"> Mail </a>

Am I off my rocker, or does an IMAP/POP translator sound like a good idea? It would make your remote mail servers look like local ones. Or what about a translator that makes a mbox format mail spool look like a directory. Can anyone think of a good use for an SMTP translator?

*Definitely: Copy my email in there to send it.* -- [[ArneBab|community/weblogs/ArneBab]]

## <a name="UUEncode"> </a> UUEncode

How about a UUEncode translator for those places you can only store ASCII. Combine this with a NNTP translator and store your data in someone's Usenet archive. Or since, (as far as I know), there are no size limitations on file names in the Hurd, why not have a filesystem translator whose underlying store is a file name. (Now ls becomes cat).

## <a name="Computation"> Computation </a>

This is from the revenge of the command-line department. Make a directory translator whose contents are a result of the computation specified in the directory name. Here's an example...

    $ settrans -a /comp /hurd/computationfs
    $ cd "/comp/3+4"
    $ ls -l
    total 0
    -rw-r--r--    1 nobody     users           0 Oct 16 11:41 7
    $
    $ cd "/comp/sqrt(2)"
    $ ls -l
    total 0
    -rw-r--r--    1 nobody     users           0 Oct 16 11:42 1.4142135623731
    $

...etc. Now think about your favorite GUI HTML editor and using File-&gt;Open on the following directory name, ``"/comp/for i in $( find / -name *.html ); do ln -s $i `basename $i`;done"`` Which would produce a directory listing with soft links to all of the \*.html files on your system. You could have all of the comforts of the shell from within that little File-&gt;Open dialog box.

## <a name="Other"> Other </a>

Just found Wolfgang Jï¿½hrling's translator [wishlist](http://www.8ung.at/shell/trans.html).

## <a name="Bochs"> Bochs </a>

A translator which works with [Bochs](http://bochs.sourceforge.net/) disk images would be nice.

## <a name="Rollover"> Rollover </a>

A translator that uses a circular buffer to store log files. The translated node only contains the last N (mega,kilo)bytes.

## <a name="Birthday"> Birthday </a>

A translator that provides an interface into the birthday program.

You can cat your calendar, eg. bd/calendar/today bd/calendar/this-week or bd/calendar/this-month.

And you could write new events into files located in bd/events/DATE/event-name.

DATE is of the format the birthday expects DD/MM/YYYY.

The contents of the file are any or none of the following birthday options: ann (An anniversary), bd (A birthday), ev (Some other event), wN (Warn N days in advance of date), toDATE (Event lasts until this DATE), forDAYS (Event runs for DAYS).

You can optionally just edit the bd/birthdays file if you want to edit the configuration file by hand. It might make sense to write changes from bd/birthdays into ~/.birthdays.

    $ settrans -c bd /hurd/birthday -f ~/.birthdays
    $ ls bd/
    birthdays  calendar  events
    $ find bd -print
    bd
    bd/calendar
    bd/calendar/daily
    bd/calendar/this-week
    bd/calendar/this-month
    bd/events
    bd/birthdays
    $

## <a name="LVM"> </a> LVM

A translator to access block devices from Linux's [Logical Volume Management](http://www.tldp.org/HOWTO/LVM-HOWTO/) would be an useful addition.

    # settrans -cap /dev/VolumeGroup0 /hurd/lvm /dev/PhysicalVolume0 /dev/PhysicalVolume1 ...
    # ls /dev/VolumeGroup0/
    home
    var
    # settrans -cap /home /hurd/ext2fs /dev/VolumeGroup0/home
    # settrans -cap /var /hurd/ext2fs /dev/VolumeGroup0/var

Probably both [LVM2](http://sourceware.org/lvm2/) and the [Device-mapper](http://sourceware.org/dm/) need to be ported.

## <a name="bridging_translator"> bridging translator </a>

A [bridging](http://bridge.sourceforge.net/faq.html) translator could improve the Hurd's networking facilities.

    # settrans -cap /dev/br0 /hurd/bridge -i eth0 -i eth1 ...
    # settrans -cap /servers/socket/2 /hurd/pfinet -i /dev/br0 -a ... -g ... -m ...

Perhaps Linux's bridging code and [utilities](http://bridge.sourceforge.net/) can be ported (or glued in) or code from one of the BSDs.

## <a name="SSH_translator"> </a> SSH translator

Presenting remote file systems through SSH similar to what gnome-vfs does.

## <a name="SMB_translator"> </a> SMB translator

Presenting remote file systems through Samba similar to what gnome-vfs does. Guiseppe Scrivano has worked on this and smbfs is available at [hurdextras](http://savannah.nongnu.org/cgi-bin/viewcvs/hurdextras/smbfs/).

## <a name="Crontab_translator"> Crontab translator </a>

Presenting a user's crontab in a filesystem where cron entries are files.

## <a name="globlink"> globlink </a>

Firmlink to a file according to a filename matching pattern. When a file goes away, the next file that is matched is automatically linked to.

    $ settrans -ac libfoo.so /hurd/globlink '/lib/libfoo*'

## <a name="alphabetfs"> alphabetfs </a>

Organize a large group of files by their first letter. Present one subdirectory for each letter in the alphabet.

## <a name="fsysoptsctl"> fsysoptsctl </a>

Send an fsysopts command to a set of translators. When you have a directory full of translators and you want to send each of them the same runtime option, this translator can do it for you.

    $ settrans -ac all /hurd/fsysoptsctl '/tmp/mystuff/*'
    $ fsysopts all --update
