diff --git a/libdde_linux26/lib/src/arch/l4/cli_sti.c b/libdde_linux26/lib/src/arch/l4/cli_sti.c
index 051f259..6a8c460 100644
--- a/libdde_linux26/lib/src/arch/l4/cli_sti.c
+++ b/libdde_linux26/lib/src/arch/l4/cli_sti.c
@@ -4,6 +4,8 @@
 
 /* IRQ lock reference counter */
 static atomic_t      _refcnt   = ATOMIC_INIT(0);
+/* Refcnt value at which unlocking the cli_lock (it's not always 0) */
+static int unlock_refcnt;
 static ddekit_lock_t cli_lock;
 
 /* Check whether IRQs are currently disabled.
@@ -57,9 +59,6 @@ void fake_local_irq_restore(unsigned long flags)
 /* Store the current flags state.
  *
  * This is done by returning the current refcnt.
- *
- * XXX: Up to now, flags was always 0 at this point and
- *      I assume that this is always the case. Prove?
  */
 unsigned long __raw_local_save_flags(void)
 {
@@ -82,7 +81,7 @@ void raw_local_irq_restore(unsigned long flags)
 {
 	Assert(cli_lock != NULL);
 	atomic_set(&_refcnt, flags);
-	if (flags == 0)
+	if (flags == unlock_refcnt)
 		ddekit_lock_unlock(&cli_lock);
 }
 
@@ -95,7 +94,9 @@ void raw_local_irq_disable(void)
 	if (cli_lock == NULL)
 		ddekit_lock_init_unlocked(&cli_lock);
 
-	nested_lock(cli_lock);
+	if (nested_lock(cli_lock))
+		/* Tell the corresponding restorer to release cli_lock */
+		unlock_refcnt = atomic_read(&_refcnt);
 	atomic_inc(&_refcnt);
 }
 
