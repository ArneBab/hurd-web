[[!meta copyright="Copyright © 2010, 2011, 2013 Free Software Foundation,
Inc."]]

[[!meta license="""[[!toggle id="license" text="GFDL 1.2+"]][[!toggleable
id="license" text="Permission is granted to copy, distribute and/or modify this
document under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no Invariant
Sections, no Front-Cover Texts, and no Back-Cover Texts.  A copy of the license
is included in the section entitled [[GNU Free Documentation
License|/fdl]]."]]"""]]

[[!tag open_issue_glibc open_issue_hurd]]

[[!toc]]


# IRC, freenode, #hurd, June (?) 2010

    <pochu> is there a way (POSIX or Hurdish) to get the corresponding file
      name for a fd or a hurd port?
    <marcusb> there is a way
    <pochu> marcusb: which one would that be?
    <marcusb> I forgot
    <marcusb> there is an implementation in libc
    <marcusb> realpath has a similar job
    <marcusb> but that's not what I mean
    <marcusb> pochu: maybe I am misremembering.  But it was something where you
      keep looking up .. and list that directory, looking for the node with the
      ID of the node you had .. for
    <marcusb> maybe it works only for directories
    <marcusb> yeah
    <marcusb> pochu: check the getcwd() implementation of libc
    <marcusb> sysdeps/mach/hurd/getcwd.c
    <marcusb> _hurd_canonicalize_directory_name_internal 
    * pochu looks
    <pochu> marcusb: interesting
    <pochu> though that is for dirs, and doesn't seem to be extensible to
      files, as you cannot lookup for ".." under a file
    <marcusb> right
    <pochu> oh you already said that :)
    <marcusb> actually, I am not sure that's correct
    <marcusb> it's probably correct, but there is no reason why looking .. up
      on a file couldn't return the directory it's contianed in
    <pochu> I don't know the interfaces or the Hurd internals very well yet,
      but it would look strange to me if you could do that
    <marcusb> the hurd is strange
    <pochu> it sounds like if you could `ls getcwd.c/..` to get
      sysdeps/mach/hurd/ :-)
    <marcusb> yep
    <pochu> ok. interesting
    <marcusb> you wouldn't find "ls foo.zip/.." very strange, wouldn't you?
    <pochu> I guess not if `ls foo.zip` listed the contents of foo.zip
    <marcusb> there you go
    <marcusb> or the other way round: would you be surprised if "cat somedir"
      would work?
    <pochu> I think so. if it did, what would it do?
    <marcusb> originally, cat dir would list the directory content!
    <marcusb> in the old unix times
    <pochu> I was surprised the first time I typed `vi somedir` by accident
    <marcusb> and some early BSDs 
    * pochu feels young :-)
    <marcusb> he don't worry, I didn't see those times either
    <marcusb> technically, files and directories are implemented in the same
      way in the hurd, they both are objects implementing the fs.defs interface
    <marcusb> which combines file and directory operations
    <marcusb> of course, files and directories implement those functions
      differently
    <antrik> marcusb: do you know why this behavior (cat on directories) was
      changed?


## IRC, freenode, #hurd, 2013-03-07

    * pinotree ponders about sending as RFC his patch for /proc/$pid/maps
    <tschwinge> Including a scheme for providing the names of mapped files?
      ;-D
    <braunr> that would be really great indeed
    <tschwinge> I have not yet researched how Linux does this.  Perhaps store
      the filename used for first opening a file as a string somewhere?
    <pinotree> tschwinge: eh, indeed that's lacking in my patch
    <braunr> i'm not sure we should aim at doing it the same way
    <youpi> I was wondering about having interfaces for naming tasks, threads,
      objects
    <youpi> that'd be useful for debugging in general
    <braunr> yes
    <braunr> i don't think we need to take namespaces into account
    <braunr> a simple name or path should be quite enough
    <tschwinge> Agreed.  "Just something!"
    <tschwinge> So, a Java toString() method for ports.
    <tschwinge> ;-)
    <braunr> yes
    <tschwinge> Oh, and could this also work recursively?  The ext2fs instance
      on /home asks its parent fs about its own path -- can it do that?  (And
      then cache that, most likely?)  Would one get rooted filesnames that way?
    <braunr> i really don't think we should link it to the VFS
    <braunr> it should merely be a name for debugging
    <youpi> yep, same for me
    <youpi> I'd say it's the linker's task of just setting a sane name
    <braunr> first, keeping it isolated prevents increasing complexity
    <braunr> next, it doesn't reduce performance
    <tschwinge> youpi: Linker?
    <tschwinge> braunr: Ack.
    <braunr> yes, ld is the one creating the mappings
    <youpi> tschwinge: the one that loads libraries
    <tschwinge> Ah, for /proc/*/maps, right.  I've been thinking more globally.


## task_get_name, task_set_name RPCs

[[!message-id "518AA5B0.6030409@verizon.net"]]


## IRC, freenode, #hurd, 2013-05-10

    <youpi> tschwinge's suggestion to put names on ports instead of tasks would
      be useful too
    <braunr> do you get task ports as easily as you get tasks in kdb ?
    <youpi> there is task->itk_self & such
    <youpi> or itk_space
    <youpi> I don't remember which one is used by userspace
    <braunr> i mean
    <braunr> when you use the debugger, can you easily find its ports ?
    <braunr> the task ports i mean
    <braunr> or thread ports or whatever
    <youpi> once you have a task, it's a matter of getting the itk_self port
    <youpi> s/port/field member/
    <braunr> so the debugger provides you with the addresses of the structs
    <braunr> right ?
    <youpi> yes, that's what we have already
    <braunr> then ok
    <braunr> bddebian: do that :p
    <braunr> hehe
    <youpi> see show all thread
    <braunr> (haven't used kdb in a long time)
    <bddebian> So, adding a name to ports like I did with tasks?
    <braunr> remove what you did for tasks
    <braunr> move it to ports
    <braunr> it's very similar
    <braunr> but hm
    <braunr> i'm not sure where the RPC would be
    <braunr> this RPC would exist for *all* ports
    <braunr> or only for kernel objects if added to gnumach.defs
    <youpi> it's just about moving the char array field to another structure
    <youpi> and plugging that
    <bddebian> But mach_task_self is a syscal, it looks like itk_self is just a
      pointer to an ipc_port ?
    <braunr> so ?
    <braunr> you take that pointer and you get the port
    <braunr> just like vm_map gets a struct vm_map from a task
    <bddebian> So I am just adding ipc_port_name to the ipc_port struct in this
      case?
    <braunr> yes
    <braunr> actually
    <braunr> don't do anything just yet
    <braunr> we need to sort a few details out first
    <braunr> see bug-hurd


# IRC, freenode, #hurd, 2011-07-13

A related issue:

    <braunr> rbraun@nordrassil:~$ vminfo $$ | wc -l
    <braunr> 1039
    <braunr> any idea why a shell would consume more than 1039 map entries ?
    <braunr> (well, not more actually)
    <braunr> even the kernel and ext2fs have around 100
    <braunr> (the kernel has actually only 23, which is very good and expected)
    <tschwinge> braunr: I agree that having some sort of debugging information
      for memory objects et al. would be quite hand.  To see where they're
      coming from, etc.
    <braunr> tschwinge: this would require naming objects at the mach level
    <braunr> e.g. when creating an object
    <braunr> giving it the path of a file for example
    <tschwinge> braunr: I have recently seen something (due to youpi fixing a
      bug) that bash is doing its own memory management.  Perhaps all these are
      such regions?
    <tschwinge> braunr: For example, yes.
    <braunr> what ?
    <braunr> ?!
    <tschwinge> braunr:
      http://lists.gnu.org/archive/html/bug-bash/2011-04/msg00097.html
    <braunr> i see

Also see email thread starting at [[!message-id
"20110714082216.GA8335@sceen.net"]].

Justus: Once [[!message-id desc="these patches"
"1375178364-19917-4-git-send-email-4winter@informatik.uni-hamburg.de"]] are
merged, there will be a way to map from ports to file names, at least for
libdiskfs and libnetfs, one would only have to make this information available
somehow.
