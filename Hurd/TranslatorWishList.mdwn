## <a name="Introduction"> Introduction </a>

The idea behind file system translators is a powerful concept which hasn't recieved much attention in the mainstream computing world. So here is a list of interesting translators I've been able to dream up. I'm sure there are many more ideas floating around out there, so add them to the list!

## <a name="Audio_cdfs"> Audio\_cdfs </a>

A translator which produces a directory of \*.wav files when you have an audio CD in the drive.

## <a name="Ogg"> Ogg </a>

This translator could be a sub-directory of the Audio\_cdfs translator and it would translate the \*.wav files into Ogg Vorbis/MP3 format.

## <a name="CDDB"> </a> CDDB

Of course it would be a lot nicer if the above two translators didn't name their files something worthless like track001.ogg. So we would want a translator which would hook up with a database on the web and produce meaningful file names.

## <a name="Crypto"> Crypto </a>

A cryptographic/steganographic seem like a nice match with the concept of user-land file systems. I like the idea of something like `settrans -a /secure stegfs --mpeg file001.mpg`

## <a name="Revision_control"> Revision control </a>

All of the empty space on your drive is now being wasted. Why not have a revision control translator which tracks changes to your documents?

## <a name="tar_and_gzip"> tar and gzip </a>

Rumor has it that they are on the way.

## <a name="ROM"> </a> ROM

How about a translator which makes it look like you can write to read only media (like CDs), or change files which I don't have permission to change. This translator would make it seem like you could copy files to places where you normally couldn't. Think about combining this translator with the ftp translator and the tar and gzip translators. (cd /ftp/gnu.org/gnome.tar.gz/writes\_allowed; make install). It could be that unionfs does this very thing.

## <a name="Super_FIFO"> Super\_FIFO </a>

It's like a named pipe which is smart enough to start a process everytime something new tries to read from it. For example, let's say I have a script that reads in a JPEG image and spits out a smaller thumbnail \*.jpg to STDOUT. With a standard fifo (`mknod -p fifo`) this would almost works (`script big.jpg > fifo`). But what if there are two processes trying to read the fifo at once? Ick. And of course the standard way only works once without rerunning the command. I'm not quite sure what the syntax should look like, but I'm sure someone out there has a great idea waiting to happen.

## <a name="Perl"> Perl </a>

Perl is a wonderful language for hacking together something useful in a short amount of time. No concept is complete without being able to use it in a perl one-liner. And that goes for Hurd translators too. Right?

    #!/usr/bin/perl
    use Hurd::translator;

    #file named "two" can produce an endless supply of twos, etc. (a la /dev/zero)
    my $i=0;
    for $filename ([zero one two three four])
    {
       $libtrivfsread_codehash{$filename}=
                sub{ $num_bytes=shift; my $data=$i; return chr($data) x $num_bytes; };
       #that's a hash of references to closures
       $i++;
    }
    translator_startup();

## <a name="Source_code"> Source code </a>

Here's a crazy thought. How about a translator for source code. You have a C source file like `hello.c` which is your normal everyday file. But there's a translator sitting underneath, so when you `cd hello.c` you get a directory with files like `main()` which represent the subroutines in `hello.c`. And of course you should be able to edit/remove those and have it modify the original source.

-- Greg Buchholz - 25 Jul 2003

Minor formatting updates.

-- [[Main/JoachimNilsson]] - 25 Jul 2003
